<?xml version="1.0"?>
<!DOCTYPE html [
<!-- Entity definitions for commonly used idioms -->
<!-- TODO - Now it accepts these, but will not expand them in place! -->
<!-- Seems we can not use many special characters in these: <> % etc -->
  <!ENTITY workfull "FOOBAR" >
  <!ENTITY workfullX "
          OPTIONAL {
              ?wobj ?wrel1 ?wobj1
              MINUS { ?wobj a bf:Work }
              MINUS { ?wobj a bf:Instance }
          }
          OPTIONAL {
              ?wobj1 ?wrel2 ?wobj2
              MINUS { ?wobj1 a bf:Work }
              MINUS { ?wobj1 a bf:Instance }
          }
          OPTIONAL {
              ?wobj2 ?wrel3 ?wobj3
              MINUS { ?wobj2 a bf:Work }
              MINUS { ?wobj2 a bf:Instance }
          }
  ">
  <!ENTITY instfull "
          OPTIONAL {
            ?inst ?irel1 ?iobj1
          }
          OPTIONAL {
            ?iobj1 ?irel2 ?iobj2
          }
          OPTIONAL {
            ?iobj2 ?irel3 ?iobj3
          }
  ">
]>

<filters  xmlns="http://indexdata.com/metaproxy">
  <filter type="sparql">
      <!-- Which sparql server to use, our demo, or your local installation -->
    <defaults uri="http://bibframe.indexdata.com/sparql/"/>
    <!--defaults uri="http://localhost:8890/sparql/"/-->

    <!-- Any search in work returns just a list of records.
         Present will make another request for each record to get the level
         of details we want, depending on the schema.  -->
    <db path="work" schema="sparql-results">
      <prefix>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns</prefix>
      <prefix>bf: http://bibframe.org/vocab/</prefix>
      <form>SELECT DISTINCT ?work </form>
      <criteria>?work a bf:Work</criteria>

      <!-- bf.uri is a simple way to get to a work -->
      <index type="bf.uri"> ?work a bf:Work FILTER( ?work  = %u ) </index>

      <!-- Title indexes, directly via work.workTitle -->
      <index type="bf.title">
          ?work bf:workTitle ?wt .
          ?wt bf:titleValue %v FILTER(contains(%v, %s))
      </index>

      <index type="bf.subtitle">?work bf:workTitle ?wt .
          ?wt bf:subtitle %v FILTER(contains(%v, %s))
      </index>

      <index type="bf.parttitle">
          ?work bf:workTitle ?wt .
          ?wt bf:partTitle %v FILTER(contains(%v, %s))
      </index>

      <!-- work.titlevariation - this could also have sub- and partTitles -->
      <index type="bf.titlevariation">
          ?work bf:titleVariation ?tv .
          ?tv bf:titleValue %v FILTER(contains(%v, %s))
      </index>

      <!-- Instance titles -->
      <index type="bf.instancetitle">
          ?inst bf:instanceOf ?work .
          ?inst bf:instanceTitle ?it .
          ?it bf:titleValue %v FILTER(contains(%v, %s))
      </index>

      <!-- Combined title index. There are so many ways titles can be expresses
      in Bibframe, this seems to cover most of what we have seen -->
      <index type="bf.anytitle">
          { ?work bf:workTitle ?wt .
              { ?wt bf:titleValue %v FILTER(contains(%v, %s)) } UNION
              { ?wt bf:subtitle %v FILTER(contains(%v, %s)) } UNION
              { ?wt bf:partTitle %v FILTER(contains(%v, %s)) }
          } UNION {
              ?work bf:titleVariation ?tv .
              ?tv bf:titleValue %v FILTER(contains(%v, %s)) 
          } UNION {
              ?inst bf:instanceOf ?work .
              ?inst bf:instanceTitle ?it .
              ?it bf:titleValue %v FILTER(contains(%v, %s))
          }
      </index>

      <!-- Author indexes -->
      <index type="bf.creator">
          ?work bf:creator ?c .
          ?c bf:label %v FILTER(contains(%v, %s))
      </index>

      <index type="bf.contributor">
          ?work bf:contributor ?c .
          ?c bf:label %v FILTER(contains(%v, %s))
          </index>

      <!-- Subjects -->
      <index type="bf.subject">?work bf:subject ?subject .
          ?subject bf:label %v FILTER(contains(%v, %s))
      </index>

      <!-- Present formats. BF-L is just the links -->
      <present type="BF-L">
        CONSTRUCT { ?work ?rel ?subj }
         WHERE {
         ?work a bf:Work .
         ?work ?rel ?subj .
         ?work ?rel ?obj FILTER( str(?work) = %s )
        }
      </present>

      <!-- BF-F expands all links, except to instances -->
      <present type="BF-F"> 
        CONSTRUCT { ?work ?rel ?obj .
                    ?obj ?rel1 ?obj1 .
                    ?obj1 ?rel2 ?obj2 .
                    ?obj2 ?rel3 ?obj3 }
         WHERE {
         ?work a bf:Work .
         ?work ?rel ?obj .
        OPTIONAL { 
          ?obj ?rel1 ?obj1  
            MINUS { ?obj a bf:Work } 
          }
        OPTIONAL {
          ?obj1 ?rel2 ?obj2 
            MINUS { ?obj1 a bf:Work } 
          } 
        OPTIONAL { 
          ?obj2 ?rel3 ?obj3 
            MINUS { ?obj2 a bf:Work } 
          }
         ?work ?rel ?obj FILTER( str(?work) = %s )
        }
      </present>

      <!-- full, with instances. Experimental! -->
      <present type="BF-FI">  
        CONSTRUCT { %u ?rel ?wobj1 .
                    ?wobj1 ?wrel1 ?wobj2 .
                    ?wobj2 ?wrel2 ?wobj3 .
                    ?inst ?irel1 ?iobj1 .
                    ?iobj1 ?irel2 ?iobj2 .
                    ?iobj2 ?irel3 ?iobj3 }
         WHERE {
          %u a bf:Work .
          %u ?rel ?wobj1 .
          OPTIONAL { <!-- note, this is not in the final construct
          the linking triplet will get included like any others -->
            ?inst bf:instanceOf %u
          } 
          &workfull; <!-- This does not seem to get expanded!! TODO -->
          OPTIONAL {
              ?wobj ?wrel1 ?wobj1
              MINUS { ?wobj a bf:Work }
              MINUS { ?wobj a bf:Instance }
          }
          OPTIONAL {
              ?wobj1 ?wrel2 ?wobj2
              MINUS { ?wobj1 a bf:Work }
              MINUS { ?wobj1 a bf:Instance }
          }
          OPTIONAL {
              ?wobj2 ?wrel3 ?wobj3
              MINUS { ?wobj2 a bf:Work }
              MINUS { ?wobj2 a bf:Instance }
          }
          <!--&instfull; -->
          OPTIONAL {
            ?inst ?irel1 ?iobj1
          }
          OPTIONAL {
            ?iobj1 ?irel2 ?iobj2
          }
          OPTIONAL {
            ?iobj2 ?irel3 ?iobj3
          }

        }
      </present>
    </db>
    <!-- Instance searches, need to be refined later. TODO -->
    <db path="instance" schema="sparql-results">
      <prefix>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns</prefix>
      <prefix>bf: http://bibframe.org/vocab/</prefix>
      <form>SELECT ?instance ?title ?format</form>
      <criteria>?instance a bf:Instance</criteria>
      <criteria>?instance bf:title ?title</criteria>
      <index type="4">?instance bf:title %v FILTER(contains(%v, %s))</index>
      <criteria>?instance bf:format ?format</criteria>
      <index type="1013">?instance bf:format %s</index>
    </db>

    <!-- Small databases -->
   
    <!-- "small" contains all the things common to all small databases -->
    <!-- It is only to be used as an include, it is not searchable, since -->
    <!-- it has no schema atribute -->
    <!-- It is divided into "smallindex", "smallbody", and a "small" that includes
    both, so that title searches can include the body, but have different indexes -->
    
    <db path="smallindex">
      <index type="any">?thing bf:label %v FILTER(contains(%v, %s))</index>
      <index type="1016">?thing bf:label %v FILTER(contains(%v, %s))</index>
    </db>

    <db path="smallbody">
      <prefix>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns</prefix>
      <prefix>bf: http://bibframe.org/vocab/</prefix>
      <form>SELECT DISTINCT ?thing </form>
      <criteria>?thing ?rel ?obj</criteria>
      <present type="BF-L">
        CONSTRUCT { %u ?rel ?obj }
         WHERE {
           %u ?rel ?obj .
         }
      </present>
      <!-- Experimental, to get just the URIs out, in proper rdf. Probably not useful 
      <uri type="BF-U">
        CONSTRUCT { %u bf:uri %u }
         WHERE {
           %u bf:label ?lbl .
         }
      </uri>
      -->
      <present type="BF-F">
          <!-- I don't think we need more than one level for these simple 
          databases -->
        CONSTRUCT { %u ?rel ?obj . 
                    ?obj ?rel1 ?obj1 .
                  }
         WHERE {
           %u ?rel ?obj .
           OPTIONAL { ?obj ?rel1 ?obj1 }
         }
      </present>
    </db>
    <db path="small" include="smallindex smallbody"/>
    
    <db path="place" schema="sparql-results" include="small" >
      <criteria>?thing a bf:Place</criteria>
      <index type="bf.place">?thing bf:label %v FILTER(contains(%v, %s))</index>
    </db>
    <db path="person" schema="sparql-results" include="small" >
      <criteria>?thing a bf:Person</criteria>
      <index type="bf.person">?thing bf:label %v FILTER(contains(%v, %s))</index>
    </db>
    <db path="meeting" schema="sparql-results" include="small" >
      <criteria>?thing a bf:Meeting</criteria>
      <index type="bf.meeting">?thing bf:label %v FILTER(contains(%v, %s))</index>
    </db>
    <db path="agent" schema="sparql-results" include="small" >
      <criteria>?thing a bf:Agent</criteria>
      <index type="bf.agent">?thing bf:label %v FILTER(contains(%v, %s))</index>
    </db>
    <db path="event" schema="sparql-results" include="small" >
      <criteria>?thing a bf:Event</criteria>
      <index type="bf.event">?thing bf:label %v FILTER(contains(%v, %s))</index>
    </db>
    <db path="organization" schema="sparql-results" include="small" >
      <criteria>?thing a bf:Organization</criteria>
      <index type="bf.organization">?thing bf:label %v FILTER(contains(%v, %s))</index>
    </db>
    <db path="topic" schema="sparql-results" include="small" >
      <criteria>?thing a bf:Topic</criteria>
      <index type="bf.topic">?thing bf:label %v FILTER(contains(%v, %s))</index>
    </db>

    <!-- Title search, probably not needed. -->
    <db path="title" schema="sparql-results" include="smallbody" >
      <criteria>?thing a bf:Title</criteria>
      <index type="any">
           { ?thing bf:titleValue %v FILTER(contains(%v, %s)) } UNION
           { ?thing bf:subtitle %v FILTER(contains(%v, %s)) } UNION
           { ?thing bf:partTitle %v FILTER(contains(%v, %s)) } 
      </index>
      <index type="1016">
           { ?thing bf:titleValue %v FILTER(contains(%v, %s)) } UNION
           { ?thing bf:subtitle %v FILTER(contains(%v, %s)) } UNION
           { ?thing bf:partTitle %v FILTER(contains(%v, %s)) } 
      </index>
      <index type="bf.title">?thing bf:titleValue %v FILTER(contains(%v, %s))</index>
      <index type="bf.subtitle">?thing bf:subtitle %v FILTER(contains(%v, %s))</index>
      <index type="bf.parttitle">?thing bf:partTitle %v FILTER(contains(%v, %s))</index>
    </db>

    <!-- A hack to be able to look at any triplet in the base -->
    <!-- TODO - Switch to the new system, probably using "small" -->
    <db path="node" schema="sparql-results">
      <prefix>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns</prefix>
      <prefix>bf: http://bibframe.org/vocab/</prefix>
      <form>SELECT ?node ?rel ?obj</form>
      <index type="any">?node ?rel ?obj FILTER( str(?node) = %s )</index>
    </db>
    <!-- A way to see which triplets refers to a given uri. -->
    <!-- TODO - Switch to the new system, probably using "small" -->
    <db path="ref" schema="sparql-results">
      <prefix>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns</prefix>
      <prefix>bf: http://bibframe.org/vocab/</prefix>
      <form>SELECT ?node ?rel ?obj</form>
      <index type="any">?node ?rel ?obj FILTER( str(?obj) = %s )</index>
    </db>
  </filter>
  <filter type="log">
    <message>http</message>
    <category apdu="true"/>
  </filter>
  <filter type="http_client">
    <x-forwarded-for>true</x-forwarded-for>
  </filter>
</filters>
